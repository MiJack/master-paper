\newpage

\addcontentsline{toc}{chapter}{ABSTRACT}
\vspace{-500pt}

\chapter*{\zihao{2}\heiti{ABSTRACT}}


%伴随着移动应用迅猛的发展，研究人员开始关注如何分析移动应用的业务逻辑，了解应用的运行行为。
%不同于传统应用程序，Android应用程序采用的是基于事件驱动的系统架构和面向组件的编程模式，业务逻辑对回调函数和多线程交互的依赖性高。
%上述特性使得程序的业务逻辑分散在不同的代码片段（例如方法、线程、组件等）中，阻碍了应用程序执行过程的建模，对了解Android应用程序执行细节造成了挑战。


With the rapid development of mobile apps, researchers have focused their attention on  mobile apps analysis,
since they want to know the runtime behavior for the application via technical approaches.
Unlike traditional programs, Android apps, based on  event-driven architecture,  take the components like Activity as  essential building blocks and  rely on callback functions and multithreaded communication heavily.
These Android features split the business logic into diffrent segments, i.e., methods, threads, and components,  making trouble to the modeling for application execution and  posing the challenge to understand the execution for Android apps.



%为此，本文提出并实现了一个可用于生成Android应用程序动态函数调用图的系统——RunDroid。
%RunDroid使用源程序代码插桩获取用户方法的执行信息，通过运行时方法拦截获取获取系统方法的执行信息，将这些信息以日志的形式保留下来。
%根据应用程序运行期间产生的日志信息，RunDroid能还原出应用的动态函数调用图。
%RunDroid构建的函数调用图不仅反映了函数间的调用关系，还能反映方法对象关系和方法间的触发关系，体现Android中Activity组件的生命周期，为程序分析工作提供必要的运行时信息。


This paper proposed  RunDroid, a system which can be used to build the dynamic function call graphs for Android apps.
RunDroid takes the source code of an app as input, obtains  execution information of user-level method via  source-code level instrumentation,
gains  information of system-level method by runtime intercept, 
and  recover dynamic function call graph for apps according to the the log information generated while app running.
The call graph, constructed by RunDroid, not only shows the calling relationship, but also reflects the method-object relationship, the trigger relationship between the methods, and the lifecycle of  Activity component, 
and provides the important runtime details for program analysis.



To study the universality of function trigger relationship, we download 9 Android apps from the open source community F-Droid, build their dynamic function call graphs using RunDroid, and count for function relationships in call graphs.
Results show that the trigger relationship is ubiquitous during app running and is playing the major role in Android.




%为了研究函数触发关系的普遍性，我们从开源社区F-Droid中下载9个开源应用程序，利用RunDroid产生动态函数调用图，统计调用图中的函数关系数量。
%实验结果显示函数触发关系在应用程序的执行过程中普遍存在，并且在业务逻辑中承担着主要的作用。

%为了研究静动态分析技术的优劣性，我们针对同一场景，分别使用FlowDroid和RunDroid产生静态函数调用图和动态函数调用图，并对它们进行对比分析。
%相比FlowDroid，RunDroid产生的函数调用图能够准确地反映应用程序的执行过程，表现函数间的调用关系和触发关系，真实地还原Android Activity组件的生命周期变迁。


In order to study the advantages and drawbacks of static and dynamic analysis techniques , 
%
we compare the static function call graphs and dynamic function call graphs generated by FlowDroid and RunDroid, separately.
%
%we use FlowDroid and RunDroid to generate static function call graphs and dynamic function call graphs for the same scene, and compare them.
%Also, we compare the call graphs generated by RunDroid and FlowDroid.
Compared with FlowDroid's static call graph, the dynamic call graph generated by RunDroid can more accurately display the execution detail for the apps, express the calling relationship and trigger relationship between functions, and restore the lifecycle of the Android component Activity.


Finally, we apply RunDroid to exploratory experiments on fault localization to illustrate the value of RunDroid.
The result shows that the call graph provided by RunDroid can  reflect the causal relationship of function execution comprehensively.
Compared with the existing studies, RunDroid makes the causal influence model between methods more complete, and provides more program dependency information, which helps to improve the accuracy of fault localization.






{\sihao{\textbf{\newline Keywords:}}} \textit{Android, Call Graph, Dynamic Analysis, Lifecycle, Multi-Thread}


































