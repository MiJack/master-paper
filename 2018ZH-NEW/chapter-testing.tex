\chapter{系统测试}  
\label{chp:testing}


\todo{
上一章详细介绍了xxxx，其中包含xxx、xxx各功能模块。
为了xxxx，本章节中，通过xxx来展示、评估系统。
}
实验相关配置的环境如下：
实验平台是ThinkPad E430，CPU为Intel 酷睿i5 3210M，内存为12GB。
手机型号为小米 MI 5，处理器型号为骁龙820，RAM为3GB，系统为Android 6.0，内置Xposed运行环境。

\eat{


\subsection{构建效率对比实验}
为了验证源代码插桩前后对应用程序的影响，我们从开源社区F-Droid\footnote{https://f-droid.org}中随机选取了\todo{十余}个Android App，比较源代码插桩前后应用构建的耗时时间，
以评估源代码插桩对应用构建的影响。

对于每个应用，我们采用Gradle进行APK构建，通过源代码插桩前后的APK大小变化、方法数变化以及APK构建整体耗时等指标。最终我们得到的结果如 \autoref{tbl:buildResult} 所示。
从\autoref{tbl:buildResult}中，我们发现，源代码插桩前后得到的APK文件方法数变化幅度不大，基本对应的数量变化在10个左右，APK大小变化在\todo{一个百分比范围}，构建时间的变化大都在\todo{一个百分比范围}上下。

由于RunDroid采用的源代码插桩方案，通过分析应用程序源代码中各个方法的语法结构，辨识出方法执行过程的方法入口和所有的方法出口，并在这些位置上提交日志代码插桩。
整个过程中，RunDroid引入了有限数量的方法，使得应用的构建耗时无明显的增加。
而文献\cite{van2013dynamic}基于AspectJ的字节码插桩方案，对于每一个方法均会在APK中声明多个新的方法（即AOP中的before通知、after通知等），以保证方法执行前后可以输出相应的信息。
该方法最大的劣势在于对于一些大型的Android应用，该方案引入的大量方法，很容易突破Android系统的方法数限制（即65536），使得应用整体的构建不可进行，APK无法构建成功。
而本方案在这个方面并没有太大的限制。


\begin{table*}[!ht]
	\centering
	
	\caption{构建效率对比实验}
	
	\label{tbl:buildResult}
	
	
	\resizebox{\textwidth}{!}{
		\begin{threeparttable}[b]
			
			\begin{tabular}{|c|c|c|c|c|c|c|c|}
				\hline
				
				\multirow{2}{0.03\linewidth}{序号}	&\multirow{2}{0.2\linewidth}{\centering{应用名}}& \multicolumn{3}{c}{未采用插桩方案}&  \multicolumn{3}{|c|}{采用插桩方案 }\\
				\cline{3-8}
				
				&	& 方法数 & APK大小 &	构建时间 &方法数 & APK大小 & 构建时间\\
				\hline
				
				1&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				2&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				3&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				4&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				5&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline		
				6&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline			
				7&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline		
				8&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline	
				9&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline	
				10&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				
				
				
			\end{tabular}
			
			%		\begin{tablenote}
			%		\end{tablenote}
			
		\end{threeparttable}
	}
\end{table*}


}

\eat{

\subsection{日志效率对比实验}

由于RunDroid需要将应用程序运行时的方法执行信息以日志的形式记录下来，而日志记录行为是磁盘读写（I/O）操作，在一定程度上属于耗时操作。
经过技术调研，我们发现Android平台上可行的日志记录方案分为以下几种：
基于Android Log机制的原生日志系统Logcat、基于Java File API的文件读写方案以及基于MMap内存映射机制实现的日志读写方案。


\begin{figure*}[!ht]
	\centering
	
	\resizebox{\textwidth}{!}{
		\begin{threeparttable}[b]
			
			\begin{tabular}{|c|c|c|c|c|c|c|c|}
				\hline
				
				\multirow{2}{0.03\linewidth}{序号}	&\multirow{2}{0.2\linewidth}{\centering{应用名}}& \multicolumn{3}{c}{未采用插桩方案}&  \multicolumn{3}{|c|}{采用插桩方案 }\\
				\cline{3-8}
				
				&	& 方法数 & APK大小 &	构建时间 &方法数 & APK大小 & 构建时间\\
				\hline
				
				1&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				2&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				3&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				4&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				5&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline		
				6&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline			
				7&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline		
				8&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline	
				9&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline	
				10&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				
				
				
			\end{tabular}
			
			%		\begin{tablenote}
			%		\end{tablenote}
			
		\end{threeparttable}
	}


\caption{构建效率对比实验}

\label{tbl:logResult}
\end{figure*}


为了评估以上几种日志的执行效率，本节进行了如下实验：
记录不同记录次数下，记录规格大小不同（\todo{数据的大小在10K $\sim$ 20K之间 }）的数据所需要的时间。
本节实验主要在移动设备上进行。
上述实验过程各个日志方案的时间消耗统计结果如 \autoref{tbl:logResult} 所示。
从\autoref{tbl:logResult}中，我们可以看出大部分情况下，Logcat、Java File API 、 MMap三种技术方案的效率依次提升，Logcat效率最低，MMap效率最高。
经过分析，我们发现Android日志系统Logcat虽然通过内存缓冲区加速日志处理，
但是，每一次日志记录操作，Logcat都会在用户空间和内核空间之间切换，减低了日志记录效率。
Java File API方法在执行过程中，不仅涉及到了用户态-内核态之间的切换，内存-页缓存-磁盘三者之间的数据拷贝在一定程度上也增加了整体上的开销。
而MMap方案只需要一次系统调用，避免了过多数据拷贝，执行效率最高。
因此在RunDroid最终实现上，我们基于MMap内存映射机制实现了日志读写方案。


\subsection{运行效率对比实验}


\begin{figure*}[!ht]
	\centering
	
	\resizebox{\textwidth}{!}{
		\begin{threeparttable}[b]
			
			\begin{tabular}{|c|c|c|c|c|c|c|c|}
				\hline
				
				\multirow{2}{0.03\linewidth}{序号}	&\multirow{2}{0.2\linewidth}{\centering{应用名}}& \multicolumn{3}{c}{未采用插桩方案}&  \multicolumn{3}{|c|}{采用插桩方案 }\\
				\cline{3-8}
				
				&	& 方法数 & APK大小 &	构建时间 &方法数 & APK大小 & 构建时间\\
				\hline
				
				1&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				2&	2   &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				3&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				4&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline
				5&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline		
				6&	2    &方法数 & APK大小 &	构建时间 & 方法数 & APK大小 & 构建时间\\
				\hline			
	
				
				
				
			\end{tabular}
			
			%		\begin{tablenote}
			%		\end{tablenote}
			
		\end{threeparttable}
	}
	
	
	\caption{运行效率对比实验}
	
	\label{tbl:hookResult}
\end{figure*}
}



\input {chapter-display.tex}