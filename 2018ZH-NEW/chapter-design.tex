\chapter{系统的设计}
\label{chp:design}


\section{系统功能}
本文以帮助研究人员和开发人员了解Android应用程序的执行过程作为基本出发点，通过设计与实现Android动态函数调用图构建系统RunDroid，生成Android应用程序运行时对应的动态函数调用图，从方法调用关系、方法间的触发关系以及方法执行的相关对象信息等多个方面较为全面地展现Android应用的执行过程，为应用程序分析提供更为多样、准确的信息。另外，系统具备一定的可拓展性，可以方便相关人员根据自身的业务需求对系统进行扩展，完成相应的需求。

\section{基本思想}



\begin{figure*}[!ht]
	\centering
	\includegraphics[width=0.8\textwidth]{./Figures/code-sample.png}
	\caption{RunDroid的基本思路}
	\label{fig:code_sample}
\end{figure*}


%在本节，
以\autoref{fig:code_sample}为例，%简要介绍一下RunDroid还原Android应用程序的函数调用图的基本思路：
\autoref{fig:code_sample}-左上为一段示例代码：在main函数执行时，程序会依次调用A、B两个函数，而B函数则会调用了C、D两个函数。
\autoref{fig:code_sample}-左下则是期望输出——函数调用图。
在本质上，函数调用图属于树。程序执行过程可以看做树的深度优先遍历过程。
函数调用图还原的关键点，在于如何在程序执行过程中输出树的遍历序列，并根据遍历序列进行还原。
通常的，树的遍历分为中序遍历、前序遍历以及后序遍历三种。
不幸的，两颗结构完全不同的树对应的遍历序列可能是一样的，
这也就意味着上述三种遍历方法均不能直接还原出函数调用图。

若在程序执行前后均记录日志（即一个方法的执行会输出两条日志：方法开始日志、方法结束日志）时，
我们得到的遍历序列是唯一的，可以直接用于函数调用图的还原。
% 而且，函数执行过程中出现的错误异常可能使得序列输出中断，阻碍调用图的构建。
为此，我们采用的基本思路如下：
通过对源程序（\autoref{fig:code_sample}-左上）进行预处理，得到包含日志记录功能的运行代码（\autoref{fig:code_sample}-右上）；
程序在函数执行前后可以输出和方法执行相关的日志信息，（\autoref{fig:code_sample}-右下）；
最后，我们根据这些日志信息构建出函数调用图（\autoref{fig:code_sample}-左下）。
在函数调用图的基础上，RunDroid利用日志中包括的方法对象信息，挖掘和方法对象相关联的方法，结合具体触发规则，进而建立方法触发关系。

% 从函数调用图的构建过程可以看出，程序的执行过程就是对函数调用图自上而下的深度优先遍历过程。由此可见，若要还原出图 6-右中的函数调用图，本文采用的基本思路是以日志方式输出对右图中的函数调用图的深度优先遍历序列，并基于得到的遍历序列还原出函数调用图。
% 由于Android是由面向对象编程语言Java开发的系统，系统还需要考虑面向对象编程的特性——多态性（即同一个行为在不同的对象下的表现可以不同）。为此，RunDroid还会在函数调用图将函数执行和对应的对象进行关联，更好地体现面向对象编程的函数调用关系。基于上述的函数调用关系的信息，RunDroid根据函数调用之间的关系进一步挖掘，进一步挖掘Android系统中的特性（例如组件Activity的生命周期、多线程的交互方式）。



\section{技术路线}

在技术实现上，RunDroid主要分为预处理器、运行时拦截器、日志记录器、调用图构建器等4个部分。
对应技术路线如下：
预处理器通过源代码插桩技术实现用户方法层面的信息记录，而运行时拦截器则负责拦截系统方法的执行。
在应用运行时，日志记录器会记录用户方法和系统方法对应的执行信息，以日志的形式记录下来。
最后，调用图构建器会根据应用程序运行时输出的日志，构建拓展函数调用图。
对应的工作流程如\autoref{fig:rundroid_overview}所示。


% 本技术路线拟利用语法分析工具，对Android应用程序进行了应用源代码层面的执行日志插桩工作，利用非侵入式系统行为修改插件获取系统层面的函数执行信息。
% 结合以上日志信息，方案对日志进行初步处理，在图数据库上构建原始的Android应用程序的动态函数调用图。
% 通过阅读分析Android系统中多线程相关的源代码，制定具体的多线程分析插件，进而在函数调用图中标识出多线程相关的方法间触发关系，
%全面地展现Android应用的执行过程。


\begin{figure*}[!ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/rundroid-overview.png}
	\caption{ RunDroid的工作流程}
	\label{fig:rundroid_overview}
\end{figure*}

\section{方法信息的捕获}

\subsection{用户方法执行信息的获取}%——基于源代码的日志代码插桩过程}


预处理器以Android项目源代码作为输入，输出预处理后的APK文件；输出的APK文件在应用执行过程中将用户方法的执行信息输出出来。
具体过程如\autoref{alg:instrument}所示：
预处理器会遍历项目源代码中的每一个Java文件，解析每一个利用srcML转化成对应的抽象语法树。
%  利用获取的语法结构，预处理器会提取出所有的方法体，
对于抽象语法树中的每一个方法，预处理器会计算出编译后所处的类的全限类名及对应的完整的方法签名（第\ref{alg:instrument:computeMethodId}行），并将这些信息以日志记录代码的形式写回到方法体中（第\ref{alg:instrument:addMethodExitLogCode}$\sim$\ref{alg:instrument:addMethodEnterLogCode}行）。
另外，日志记录代码记录了和方法相关的方法对象信息：和方法有参数或者实例关系的对象会在方法执行时输出到日志，方法的返回值对象则是在方法结束以后输出到日志中。
全限类名和方法签名的组合<全限类名，方法签名>和抽象语法树中的方法体一一对应，可以看做方法体的唯一标识，因此我们根据这些日志信息，定位到具体对应的方法体，还原出函数调用关系，构建出函数调用图。
另外，预处理器还对每个方法体进行了异常捕获处理，防止方法体内部的异常导日志记录过程的中断，影响函数调用图的构建（第\ref{alg:instrument:addMethodCatchLogCode}行）。
最后，预处理器会将插桩后的源代码构建成APK文件（第\ref{alg:instrument:buildApk}行）。




\begin{algorithm}[!ht]
	\caption{日志代码插桩过程} 
	\label{alg:instrument}
	\KwIn{ $javaFiles$，应用程序的源代码}
	\KwOut{ $apk$，包含插桩代码的APK文件}
	\SetKwProg{Fn}{Function}{:}{}
	
	\Fn{buildApk($log$)}{
		
		\For{$ javaFile \in javaFiles $}{
			
			transform $javaFile $ to xml-format File $xmlFile$
			
			transform $xmlFile$ to DOM Object $document$
			
			\For{ \emph { $ classEle \in document$}}{
				
				$className \gets $computeClassSign($classEle$,$xmlFile$); 	
				
				\For{\emph { $methodEle \in classEle$}}{
					
					$methodId\gets $computeMethodId($methodEle$,$className$ ); 	 \label{alg:instrument:computeMethodId}
					
					addMethodExitLogCode($methodEle$,$methodId$); \label{alg:instrument:addMethodExitLogCode}
					
					addMethodCatchLogCode($methodEle$,$methodId$);  \label{alg:instrument:addMethodCatchLogCode}
					
					addMethodEnterLogCode($methodEle$,$methodId$); \label{alg:instrument:addMethodEnterLogCode}
				}
				
			}
			write $document$ into new Java File $newJavaFile$
			
		}
		$	apk  \gets buildApk(newJavaFiles)$  \label{alg:instrument:buildApk}
		
		\KwRet{apk };
	}
	
\end{algorithm}
\subsection{系统方法执行信息的获取}%——基于动态拦截技术的方法信息捕获}



运行时拦截器的主要职责是对Android系统定义的方法执行进行拦截，将相关信息传递给日志记录器，弥补预处理器无法捕获系统方法执行信息的缺陷。
运行时拦截器可以帮助提供系统方法的执行信息，填补调用图缺失的系统方法执行，进而可以还原出应用层和系统层之间以及系统内部的方法调用，产生完整的方法调用，进而帮助我们还原出方法间的触发关系。



\section{扩展函数调用图的构建过程}

调用图构建器构建拓展函数调用图的过程分为两个阶段：RunDroid根据程序运行时的日志提取函数间的调用关系，创建函数调用图；
在函数调用图的基础上，RunDroid利用方法执行与方法对象的关联关系，结合具体的触发关系规则，创建方法间的触发关系，形成最终的拓展函数调用图。


\begin{algorithm}[!ht]
	\caption{函数调用图的构建过程} 
	\label{alg:buildCG}
	\KwIn{ $logs$，应用程序的运行时日志}
	\KwOut{ $cg$，函数调用图}
	\SetKwProg{Fn}{Function}{:}{}
	
	\Fn{buildCallGraph($log$)}{
		
		$cg$ $\gets$ new CallGraph();
		
		\For{thread $\in$ $logs.threads$}{
			
			$stack$ $\gets$ new Stack();
			
			\For  {$log$ $\in$ $logs.get(thread)$}{
				
				$top$ = $stack$.peek() ;  
				
				\eIf{isMethodStartLog($log$)} {
					
					$m \gets $ generateMethodInfo($log$);
					
					$cg$.addMethodNode($m$);
					%\Comment 在调用图中提交方法节点 
					
					$cg$.addMethodObjects($ o_p $,$o_i $) 	;							
					
					$cg$.addMethodObjectRels($ \left\langle  o_p \joinrel\xrightarrow{parameter}   m \right\rangle   $,$ \left\langle  o_i \joinrel\xrightarrow{instance}   m \right\rangle  $) ;
					
					%	\Comment 在调用图中提交方法对象节点 （此处只涉及参数关系和实例关系）
					
					\If {  $top \neq null $ }{
						
						$cg$.addInvokeRel($ \left\langle  top \to  m \right\rangle  $) ;
						
						$stack$.push($m$);
					}
					
				}{ 
					
					$cg$.addMethodObject($  o_r  $) ;
					
					$cg$.addMethodObjectRel($ \left\langle   o_r \joinrel\xrightarrow{return}   m \right\rangle  $) ;
					
					%		  \Comment 在调用图中提交方法对象节点 （此处只涉及返回值关系）
					
					$stack$.pop() ;
					
				}
				
				
				
			}
		}
	\KwRet{ $cg$};
	}
	
\end{algorithm}

\subsection{构建函数调用图}

%虽然所有线程的方法日志输入到同一个文件中，但是，从单个线程的视角看这些日志，日志在时间维度上的先后顺序就是对调用图的深度遍历。
%已检测的应用程序将日志输出到单个文件中。
%虽然所有线程的日志都输出到一个日志文件中，但在每个线程的视图中，日志条目的输出顺序遵循调用图的顺序遍历：调用方法在被调用方法之前输出。
%此外，每个方法执行对应于两个日志条目：方法入口和出口的日志条目。

由于各个线程在执行过程中，不存在一个调用关系跨越两个线程，因此，在整个构建过程中，RunDroid以产生日志的线程为基本构建单元，向调用图添加方法调用关系。
函数调用图的构建过程如\autoref{alg:buildCG}所示。
对于每个线程，RunDroid顺序遍历对应的日志，使用栈$stack$的入栈、出栈操作来模拟对应线程的函数执行的过程，还原调用关系（第3$\sim$ 20行）：
当读取到方法执行的开始日志时，系统会在调用图创建一个节点表示该方法的执行（第7$\sim$8行），
同时也在调用图中添加方法参数、方法实例对应的对象节点$o_p$、$o_i$以及方法对象和方法的关系$ \left\langle  o_p \joinrel\xrightarrow{parameter}   m \right\rangle   $、$ \left\langle   o_i \joinrel\xrightarrow{instance}   m \right\rangle  $（第9$\sim$10行）。
如果此时当前线程栈$stack$的栈顶方法元素$top$存在，系统会创建从方法$top$到当前方法$m$的调用关系，$\left\langle top \to m \right \rangle  $，并将当前方法$m$压入栈$stack$中（第11$\sim$ 14行）。
当读取到方法执行的结束日志时，该日志对应的方法必然是栈顶方法$top$，若栈顶方法$top$存在返回对象$o_r$，则只需要将$o_r$和$top$的关系添加到调用图中即可，最后弹出栈顶的$top$即可（第 16$\sim$ 18行）。
在上述过程中，如果待添加的方法对象在调用图中已经存在时，该对象则无须重新添加，只需添加方法与对象间的关系即可。


% 当日志条目表示方法条目时，将根据日志条目和来自的4元组信息创建节点 日志存储在节点中（第6行）。
%然后，从堆栈顶部的方法到日志条目中的方法（第7-9行）构建调用关系。
%处理完调用关系后，该方法将被推入堆栈。当日志条目表示方法退出时，堆栈将弹出顶部的方法节点（第11-12行）。
%重复该过程，直到没有为一个线程留下日志条目，然后将为日志文件中的另一个线程启动相同的进程。

%构建扩展调用图。 
%DROIDSTITCHER通过添加表示已识别触发关系的边来扩展调用图。
%请注意，触发器关系中的目标方法通常是回调方法的调用图的入口点。
%因此，通过将触发关系添加为边，将所有调用图拼接成一个调用图作为输出。


\begin{algorithm}[!ht]
	\caption{构建Activity的生命周期} 
	\label{alg:buildActivityLifecycle}
	\KwIn{ $cg$，函数调用图}	
	\KwIn{ $activity$，AndroidManifest定义的Activity组件}
	\KwOut{ $cg'$，包括Activity生命周期的函数调用图}
    


	\SetKwProg{Fn}{Function}{:}{}
	
	\Fn{patchActivityLifecycle($cg$)}{
		
		%	$cg'  \gets  cg$;
		
		从AndroidManifest文件中解析Activity组件
		
		$list \gets$ new   $ List()$;
		
		\For{ \emph{ $m \in \{ m \mid  m$ is the method node in $ cg \}$}}{
			\If{ \emph{ $m$ is the method of Activity's Lifecycle   \\\qquad  
					and   {$  \left\langle  m' \to m \right\rangle  \notin cg$} }}{
				
				$list$.add($m$);
			}
		}
		linkItemByTime($list$);
		
		
		\KwRet{$cg$};
	}
	
\end{algorithm}


\subsection{构建Activity的生命周期}

Android Acticvity生命周期的构建利用的是\code{Activity}生命周期相关方法的签名的不变性。
具体过程如\autoref{alg:buildActivityLifecycle}所示：
遍历调用图中所有的方法，如果一个方法的方法签名属于第\ref{chp:background}章中\autoref{fig:Activity-lifecycle}定义的方法，并且这个方法在调用图中不在调用者，执行线程为主线程，则这些线程为Activity生命周期的相关方法。
将上述方法按照时间顺序连接起来，即可得到\code{Activity}的生命周期。
\question{不允许调用者存在是为了防止误判下面这种情况：开发人员在重写生命周期方法时调用了父类的生命周期方法}


 \subsection{构建多线程触发关系}
在构建多线程触发关系时，我们只要分为两个方面：基于Java 的多线程交互与基于\code{Handler} 的多线程消息调度。具体的过程如\autoref{alg:buildTrigger}所示。



\begin{algorithm}[!ht]
	\caption{扩展函数调用图的构建过程}
	\label{alg:buildTrigger}
	\KwIn {	$cg$， 函数调用图} 
	\KwOut {	$ecg$，拓展函数调用图}
	
	
	\SetKwProg{Fn}{Function}{:}{}
	\Fn{buildExtendedCallGraph($cg$)}{
		
		$ecg \gets cg$;
		
		addThreadTrigger($ecg$);
		
		addHandlerTrigger($ecg$);
		
		\KwRet $ecg$;
	}
	
	% $o_p \stackrel{parameter}{\longrightarrow} m$
	\Fn{addThreadTrigger($ecg$)} {
		\For{\emph{$o_r \in \{ o \mid o $  is the $Runnable$ object node ,$o \in$ $ecg \}$} }{
			\If{ {$ \left\langle m_{start}\joinrel\xrightarrow{instance} o_r \right\rangle \in ecg$ } \\\qquad 
				and   {$\left\langle m_{run} \joinrel\xrightarrow{instance}   o_r\right\rangle  \in ecg$ }}{
				$ecg$.addTriggerRel($m_{start} \lhook\joinrel\xrightarrow{Thread}  m_{run} $)	
			}
			\If{ {$ \left\langle m_{runOnUiThread} \joinrel\xrightarrow{parameter}   o_r \right\rangle \in ecg$}  \\\qquad   
				and  { $\left\langle m_{run} \joinrel\xrightarrow{instance}   o_r\right\rangle  \in ecg$  }}{
				$ecg$.addTriggerRel($m_{runOnUiThread}  \lhook\joinrel\xrightarrow{runOnUiThread}  m_{run} $)	
			}	
		}
	}	
	\Fn{addHandlerTrigger($ecg$)} {
		
		\For{\emph{ $o_m \in  \{ o\mid$ o is the $Message$ object node ,$o \in$ $ecg \}$} }{
			\If{{ $ \left\langle m_{enqueue}\joinrel\xrightarrow{parameter} o_m\right\rangle \in ecg$}  \\\qquad   
				and  { $\left\langle m_{dispatch}\joinrel\xrightarrow{parameter} o_m\right\rangle  \in ecg$ }}{
				$m_{send}$ =  calculateSendMethod($ecg$,$m_{enqueue}$);
				
				$m_{handle}$ =  calculateHandleMethod($ecg$,$m_{dispatch}$);
				
				$ecg$.addTriggerRel($m_{send} \lhook\joinrel\xrightarrow{Handler} m_{handle} $ )	
			}	
		}
	}
	
\end{algorithm}
\point{基于Java 的多线程交互}

基于Java的多线程交互往往是以\code{Runnable}作为传递对象，通常通过调用方法\code{Thread.start()} （用$m_{start}$表示）和\code{Activity.runOnUiThread(Runnable)}（用$m_{runOnUiThread}$表示）等API，进而触发方法\code{Runnable.run()}（用$m_{run}$表示）的执行。
因此，对于方法\code{Thread.start()}，如果存在一个\code{Runnable}类型的对象\code{r}，它既是方法$m_{start}$的实例，又是方法$m_{run}$的实例，则两个方法间存在触发关系，即$m_{start} \hookrightarrow m_{run}$（第8 $\sim$10行）。
同样的，对于方法\code{Activity.runOnUiThread(Runnable)}，也存在类似的关系：
如果存在一个\code{Runnable}类型的对象\code{r}，它既是方法$m_{runOnUiThread}$的参数，又是方法$m_{run}$的实例，则两个方法间存在触发关系，即$m_{runOnUiThread} \hookrightarrow m_{run}$（第11 $\sim$13行）。

\eat{\begin{equation}
	\label{equ:rule_1}
	\left. \begin{gathered}
	o_r    \        is           \      Runnable  \      Class \\
	rel(m_{start}, o_r) = instance \\
	rel(m_{run}, o_r) = instance \\
	\end{gathered} \right\}
	\Rightarrow  m_{start} \hookrightarrow m_{run}. 
	\end{equation}
}
\eat{
\begin{equation}
\label{equ:rule_2}
\left. \begin{gathered}
o_r    \        is           \      Runnable  \      Class \\
rel(m_{runOnUiThread}, o_r) = parameter \\
rel(m_{run}, o_r) = instance \\
\end{gathered} \right\}
\Rightarrow  m_{runOnUiThread} \hookrightarrow m_{run}. 
\end{equation}
}








\point{基于\code{Handler} 的多线程消息调度}

根据第\ref{chp:background}、\ref{chp:definition}章的介绍，我们已经知晓用户通过调用Handler提供的API，
将相关业务逻辑借助Message对象传递给目标线程的Handler对象，在目标线程执行相应的业务逻辑处理。
%在这个部分，我们需要找出用户调用的Handler API和对应目标线程的业务逻辑方法间的触发关系：
首先，我们利用类\code{Handler}的方法\code{enqueueMessage(Message)}（用$m_{enqueue}$表示）和\code{dispatchMessage(Message)}（用$m_{dispatch}$表示）公用同一个Message对象的特点，
找到所有的Handler底层函数触发关系 ，$m_{enqueue}  \hookrightarrow  m_{dispatch}$ （第16$\sim$17 行）；
对于每一个触发关系 $m_{enqueue}  \hookrightarrow  m_{dispatch}$，
从$m_{enqueue}$ 顺着调用关系往上找到最上层的Handler API方法（即用户调用的Handler API方法，$m_{send}$）（第18行），
从$m_{dispatch}$ 顺着调用关系往下找到用户定义的方法\code{Handler.handleMessage(Message)}$m_{handle}$（第19行），
最后在调用图中提交方法$m_{send}$和$m_{handle}$之间的触发关系 $m_{send} \lhook\joinrel\xrightarrow{Handler} m_{handle}$（第20行）。
%如果$m_{send}$和$m_{handle}$中有一个方法未找到，表示


\eat{
MATCH (SEND:METHOD)-[:PARAM]->(MSG:OBJECT),

(SEND:METHOD)-[:INSTANCE]->(HANDLER:OBJECT),

(HANDLE:METHOD)-[:PARAM]->(MSG:OBJECT),

(HANDLE:METHOD)-[:INSTANCE]->(HANDLER:OBJECT)

WHERE SEND.methodSign ='boolean android.os.Handler.enqueueMessage(android.os.MessageQueue,android.os.Message,long)'

AND HANDLE.methodSign ='void android.os.Handler.dispatchMessage(android.os.Message)'

RETURN SEND,HANDLE
	
	
	
	
MATCH p=(method:METHOD)-[:INVOKE*0..]->(enqueue:METHOD),

(enqueue)-[:TRIGGER\_PREPARE\_HANDLER]->(dispatch:METHOD)

AND  NOT (enqueue)-[:INVOKE]->()

RETURN p,method,enqueue,dispatch;

	
	
MATCH p=(method:METHOD)-[:INVOKE*0..]->(enqueue:METHOD),

(enqueue)-[:TRIGGER\_PREPARE\_HANDLER]->(dispatch:METHOD)-[r:INVOKE]->(run:METHOD)

WHERE method.methodSign IN [

'boolean android.os.Handler.post(java.lang.Runnable)',

'boolean android.os.Handler.postAtTime(java.lang.Runnable,long)',

'boolean android.os.Handler.postAtTime(java.lang.Runnable,java.lang.Object,long)',

'boolean android.os.Handler.postDelayed(java.lang.Runnable,long)']

RETURN p,method,enqueue,dispatch, run

	
	
	
MATCH p=(method:METHOD)-[:INVOKE*0..]->(enqueue:METHOD),

(enqueue)-[:TRIGGER\_PREPARE\_HANDLER]->(dispatch:METHOD)

AND  NOT (enqueue)-[:INVOKE]->()

RETURN p,method,enqueue,dispatch

	

}

\eat{识别触发关系。
触发关系表示由于Android框架的生命周期事件，系统事件和多线程通信而导致的方法的隐式调用。
以Handler为例。 sendMessage方法隐式意味着稍后将执行相应的方法handlerMessage。
为了捕获这种关系，我们确定了一种模式：sendMessage方法通过传递消息对象来触发方法handlerMessage。
因此，如果我们可以找到用作方法sendMessage和方法handlerMessage的参数的消息对象，那么我们可以在这两个方法之间创建触发器关系。
在分析了Android框架的源代码之后，我们确定了线程，窗口小部件的侦听器注册和异步任务的类似模式。
因此，DROIDSTITCHER维护一个方法列表，这些方法是触发器关系的潜在目标，并比较这些方法中消息对象的内存地址以推断关系。
}



 \section{本章小结}

本章详细介绍了RunDroid的设计。
首先，本章简要介绍了RunDroid实现的基本功能，并通过一个简单的例子介绍了RunDroid运行的基本思路。
由此，我们提出了RunDroid具体的技术路线：RunDroid利用源代码插桩和运行时拦截器相结合的方式，将运行时的方法执行信息以日志的形式保存下来，通过线程内部各个方法日志的嵌套关系还原出函数调用图，并利用调用图中方法和方法对象之间的关系结合具体的触发关系补全方法间的触发关系，形成最终的拓展函数调用图。
