\chapter{名词解释}
\label{chp:definition}


在本节，我们将给出拓展动态函数调用图构建过程中的基本术语：方法执行、方法对象、调用关系、触发关系、函数调用图、拓展函数调用图等，并将结合具体示例进行解释。

\section{概念说明}
方法执行是一个方法执行相关信息的描述，方法对象对应是和方法执行相关的对象；
调用关系和触发关系描述了方法执行之间的关系。
函数调用图为所有调用关系的集合，在函数调用图上添加方法对象以及触发关系得到拓展函数调用图。

\subsection{关于方法和对象的定义}

\begin{Def}
	方法对象（Method Object，MO）
\end{Def}

和方法执行相关的对象称为方法对象，可以体现对象和执行方法的相互关系。
在本文中，方法对象通常用符号$o$表示。
	

	对于一个方法执行$m$，对象和方法执行的关系有如下几种：
	\begin{itemize}
%				\setlength{\itemsep}{-5pt}
				\setlength{\itemsep}{1pt}
				\setlength{\parskip}{0pt}
				\setlength{\parsep}{0pt}
		\item 参数关系：若对象$o_p$是这个方法$m$的参数，记为$m \joinrel\xrightarrow{parameter} o_p$;%，或者 $ rel(m,o_p) = parameter$，或者三元组$\left\langle m, o_p, parameter\right\rangle $；
		\item 返回值关系：若对象$o_r$是这个方法$m$的返回值，记为$m \joinrel\xrightarrow{return} o_r$;%，或者 $ rel(m,o_r) = return$，或者三元组$\left\langle m, o_p, return\right\rangle $；
		\item 实例关系：若方法$m$是非静态方法，则方法执行时我们可以获取到关联到的this指针对象$o_i$，记为$m \joinrel\xrightarrow{instance} o_i$。%，或者 $ rel(m,o_i) = instance$，或者三元组$\left\langle m, o_p, instance\right\rangle $；
	\end{itemize}

通常情况下，一个方法执行过程中，返回值和实例只允许有一个，而方法参数可以有多个\footnote{\textbf{注：}返回值为void的方法无返回值对象，静态方法无实例对象}。
一个对象可以同时是一个方法执行过程中的实例、参数或者返回值，具体情况由函数调用的上下文决定。



\begin{Def}方法执行\end{Def}

方法执行是对方法执行过程中的相关信息的描述，完整的信息包括对应方法的完整签名、执行时所处的线程以及相关的方法对象。
在本文中，方法执行通常用符号$m$表示。

\subsection{关于方法间关系的定义}
\begin{Def}
	调用关系（Invoke）
\end{Def}

	对于程序$P$的两个方法$m_1$和$m_2$，方法$m_1$调用了方法$m_2$，则记作$m_1 \to m_2$，称为方法$m_1$调用方法$m_2$。

在此基础上，对于方法$m$，若存在方法$m_i$（$i=0,\dots,n , n \geqslant 0$），使得~\autoref{equ:extend_invoke}成立，则记作$m_0 \stackrel{\ast}{\to} m$，称为方法$m_0$扩展调用方法$m_n$。
特殊的，对于方法$m_1$和方法$m_2$，若$m_1 \to m_2$，则$m_1  \stackrel{\ast}{\to}  m_2$也成立。

\begin{equation}
m_0 \to m_1 \to \dots m_n \to m  \label{equ:extend_invoke}
\end{equation}


\important{在系统源代码的层面上}，如果对于方法$m$和$m'$，方法$m$的执行过程总是会调用方法$m'$（即$m \to m'$\important{总是}成立），可以记为 $m \Rightarrow m'$；
如果对于方法$m$和$m'$，$m  \stackrel{\ast}{\to}  m'$总是成立，可以记为 $m  \stackrel{\ast}{ \Rightarrow } m'$。

\begin{Def}
	触发关系（Trigger）
\end{Def}
	
	%如果对于动态函数调用图$DCG$中两个方法（不妨记为$m_a$和$m_b$，$m_a \in DCG$，$m_b \in DCG $），
	若方法$m_a$和方法$m_b$之间同时需要满足以下三个条件，
	则两个方法存在触发关系，记为$m_a \hookrightarrow m_b$ 或者$m_{a} \lhook\joinrel\xrightarrow{\text{因果关系}}  m_{b} $，称为$m_a$触发调用$m_b$：
	
	\begin{itemize}
		\setlength{\itemsep}{-5pt}
		\item 方法$m_a$的执行时间总是在方法$m_b$的执行时间之前；
		\item $m_a \stackrel{\ast}{\to} m_b $不成立；
		\item $m_a$、$m_b$之间存在着因果关系，包括但不限于事件回调或多线程交互等。
	\end{itemize}


以多线程中的Thread为例，方法\code{Thread.start()}（记为$m_{start}$）的执行会使JVM / Dalvik虚拟机创建一个新的线程。
最终，虚拟机会在新的线程中回调该Thread对象的方法\code{Thread.run()}（记为$m_{run}$）。
上述描述可以表示成$m_{start} \hookrightarrow m_{run}$。由于这个触发关系和多线程相关，也可以记作$m_{start} \lhook\joinrel\xrightarrow{Thread}  m_{run} $。
同样的，触发关系也适用于Ui事件注册与响应\footnote{Ui事件注册与响应指的是控件的点击事件，例如\code{View.setOnClickeListener(View\$OnClickListener)}和\code{View\$OnClickListener.onClick(View)}的关系} 、基于Handler的多线程交互。


\important{在系统源代码的层面上}，对于方法$m_a$ ,$m_b$ ,$m_c$ ，
若$m_a  \stackrel{\ast}{ \Rightarrow } m_b$ 和 $m_b \hookrightarrow m_c$\important{同时}成立，则$m_a \hookrightarrow m_c$也成立；
若$m_a  \hookrightarrow m_b$ 和 $m_b \stackrel{\ast}{ \Rightarrow }  m_c$\important{同时}成立，则$m_a \hookrightarrow m_c$也成立。

\subsection{关于调用图的定义}

\begin{Def}
	函数调用图（CallGraph，CG）
\end{Def}	

	函数调用图是对程序运行时行为的描述，用有向图$CG = ( V , E)$表示。 图中的点$ v \in V $表示一个\textbf{方法执行} $m$；
	如果方法$m_1$调用方法$m_2$（即$m_1 \to m_2$），则有向边 $e = \left\langle m_1 ,m_2 \right\rangle $属于集合 $E$。 


\textbf{注意：}
在应用执行过程中，方法A被调用了两次，方法A的每次调用都调用了方法B，则对应的函数调用图$CG$如~\autoref{equ:dcg_sample}所示。
在调用图$CG$中，$m_a$ 和 $m_b$ 各有两个，分别对应的两次\textbf{方法执行}。
$\left\langle m_{a_{1}} \to m_{b_{1}}\right\rangle $对应的是第一次函数A调用函数B，
$\left\langle m_{a_{2}} \to m_{b_{2}} \right\rangle    $对应的是第二次函数A调用函数B，

\begin{equation}
\begin{aligned}
CG = &(V,E) ,\\ 
V = & \{m_{a_{1}},m_{b_{1}},m_{a_{2}},m_{b_{2}}\}, \\ 
E = & \{  
\left\langle  m_{a_{1}} \to m_{b_{1}} \right\rangle  ,\left\langle  m_{a_{2}} \to m_{b_{2}}\right\rangle 
\} 
\end{aligned}
\label{equ:dcg_sample} 
\end{equation}



\begin{Def}
	拓展函数调用图（Extended CallGraph，ECG）
\end{Def}


	在函数调用图（CG）的基础上，添加了方法对象和函数间的触发关系。
	拓展函数调用图中的节点包括方法执行节点和方法对象节点。图中的边包括描述方法间关系的边和描述方法和对象间的边：
	前者的方法间关系包括调用关系和触发关系；而后者的关系包括和方法对象相关的三个关系。
	
\eat{
	具体定义如~\autoref{equ:def_edcg}所示：

\begin{equation}
\begin{aligned}
EDCG =              & (V_{EDCG},E_{EDCG}) ,\\ 
DCG =                & (V_{DCG},E_{DCG}) ,\\ 
V_{EDCG} =      & V_{method} \bigcup V_{object} ,\\
V_{method} =   & V_{DCG}, \\ 
G_{EDCG} =      & G_{method} \bigcup G_{object} , \\
G_{method} =  & E_{DCG} \bigcup \{ \left\langle m_1 , m_2 \right\rangle  \mid m_1 \hookrightarrow m_2 \}
\end{aligned}
\label{equ:def_edcg} 
\end{equation}
}
	
	
\section{举例说明}



以第\ref{chp:background}章中的\autoref{fig:handler-code}为例，我们将简要阐述上述概念。
在线程WorkerThread中，方法\code{run()}\eat{$m_{run}$}依次调用了方法\code{Message.obtain()}\eat{$m_{obtain}$}和方法\code{Handler.sendMessage(Message)}\eat{$m_{send}$}，则有$m_{run} \to m_{obtain} $和$m_{run} \to m_{send}$。
对于方法$m_{ontain}$，$o_{m} \joinrel\xrightarrow{return} m_{obtain} $成立。
对于方法$m_{send}$，$o_{m} \joinrel\xrightarrow{parameter} m_{send} $、$o_{handler} \joinrel\xrightarrow{instance} m_{send} $成立。
%在Handler的方法handleMessage(Message)中，则有$m_handle \to $
通过对Android Handler 运行机制的分析，我们知道$m_{send} \stackrel{\ast	}{\Rightarrow} m_{enqueue} $、$m_{enqueue} \hookrightarrow m_{dispatch}$以及$m_{dispatch} \stackrel{\ast}{\Rightarrow}  m_{handle}$，
因此，$m_{send} \hookrightarrow m_{handle}$或$m_{send} \lhook\joinrel\xrightarrow{Handler}  m_{handle} $。





\section{本章总结}

本章从方法和对象的关系、方法间关系、调用图等几个方面对方法关系、方法执行、调用关系、触发关系、函数调用图、拓展调用图等概念做了符号化的定义，
并结合第二章的Handler例子简单阐述了上述概念。
