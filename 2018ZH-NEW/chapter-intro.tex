\chapter {绪论}
\label{chp:intro}

\section{研究背景}

%随着移动互联网时代的到来，Android应用
根据著名网站Statista的统计\cite{GoogleP55:online}显示，Android官方应用平台 Google Play Store在2009年12月至2018年6月期间的应用数量变化如~\autoref{fig:app_number}所示。
Google Play Store于2008年8月上线，截止2018年3月，在Google Play Store 上架的应用已经超过330 万。
这个数字在2013年7月才刚刚突破100万。这反映出移动应用迅猛的增长趋势。

\begin{figure*}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{./Figures/app-numbers.png}
	\caption{Google Play Store上架的应用总数的变化趋势}
	\label{fig:app_number}
\end{figure*}


正因为移动应用迅猛的增长趋势，学术界和工业届的相关人员开始研究如何通过技术手段分析移动应用的代码内容，了解应用本身的运行时行为，进行相关学术研究和工业生产。
利用程序分析技术，研究人员对应用程序的项目相关源代码、配置文件或者二进制分发文件进行分析，监控程序的运行时行为，总结出应用程序相关特征。
结合具体应用场景，我们对这些特征进行归纳总结出相关规律，应用在应用分析、安全风险以及质量保障等领域，进一步提升应用程序的易用性、安全性和可靠性。

从分类上看，根据分析过程中是否需要运行目标程序，我们可以将这些技术手段分为静态分析技术和动态分析技术。
如果分析过程不依赖于目标程序的运行，这种分析技术称为静态分析技术，反之则为动态分析技术。
静态分析技术通常以二进制程序文件或者程序源代码作为研究主体，结合控制流分析、数据流分析技术、指针分析以及程序依赖分析，得出应用程序相关的函数调用图、UML类图和序列图等，并在此基础上进行学术研究。
%\footnote{在Java语言中，函数称为方法。在本文中，两者可以相互替换，不做区分。}。
%的控制依赖和数据依赖（两者统称为程序依赖）；
%根据程序方法内相关函数/方法调用，可以得到函数调用图、UML类图和序列图；
%我们将程序依赖数据和函数调用图相结合，可以进一步得到过程间程序依赖，
%帮助研究人员了解程序整体层面的业务间的依赖关系，进行污点传播分析\cite{stafford2000formal}。
相反的，动态分析技术依赖目标程序的运行，通过修改目标程序的运行文件，搭建目标程序的运行环境，记录程序运行过程中相关操作信息，监控目标程序在运行过程中的状态变迁或指标变化，
进而得出程序在运行过程中的行为特定，帮助研究人员进行程序安全性分析，提升程序的质量可靠性。




但是，上述两种技术各有各的优劣。
静态分析技术有着较为扎实的理论基础，覆盖较多的场景，分析较为全面，分析结果通常情况下精确可靠。
但是，静态分析技术在枚举所有情况时，往往会遇到状态爆炸的问题，具体实验效果受到实验运行环境的硬件条件和算法实现程度的限制。
而且，当静态分析技术分析的问题依赖于外部环境（用户实时操作序列、手机所处环境因素，如温度等）时，分析得到的结果并不是非常准确。
动态分析技术却能解决上述问题，通过对程序运行状态的监控，研究人员可以了解程序的运行行为，掌握程序的安全性信息和可靠性信息。
另外，动态分析技术还能解决动态代码加载的问题。
但动态分析技术的短板也非常明显：动态运行环境的搭建需要一定的技术要求，构建系统的时间成本大。
另外，动态分析技术的分析结果往往只针对一次程序的运行过程，无法直接推广到其他运行情况，结果的拓展性差。





\section{Android分析技术}

在Android软件分析领域，软件分析技术主要分为静态分析技术和动态分析技术两类。

\subsection{静态分析技术}


在不执行应用程序的情况下，静态分析技术通过对应用程序的源代码或者执行文件进行控制流分析和数据流分析，进而推断应用程序在运行过程中可能产生的行为。
这方面相关工具包括\cite{vallee1999soot,arzt2014flowdroid,AmanDroid,iccta,androguard:online,pxb1988d85,javadeco45,iBotPeac46,maaaazan93}。
%Soot\cite{vallee1999soot}、FlowDroid\cite{arzt2014flowdroid}、AmanDroid\cite{AmanDroid}、IccTA\cite{iccta}、AndroGuard\cite{androguard:online}、Dex2Jar \cite{pxb1988d85}、JD-GUI\cite{javadeco45}、APKTool\cite{iBotPeac46}、AndroWarn\cite{maaaazan93}等。
Soot\cite{vallee1999soot}是传统的静态分析工具，其思路是将所有的Java字节码文件转化成一种中间语言Jimple，并在Jimple的基础上进行常规的控制流分析、数据流分析，理论上适用于所有可以在Java虚拟机上运行的语言（例如Scala、Groovy等等）的分析。
由于Android程序本身的字节码Davlik和Java字节码在格式上保持一致，因此，Soot也支持Android应用程序的静态分析。
但是，Soot在分析过程中没有考虑一些Android的特性难免会出现一些问题。
为此，德国达姆施塔特工业大学的Steven Arzt等人在Soot的基础上考虑Android程序中Activity的生命周期特性，推出了一个针对Android的静态分析工具FlowDroid\cite{arzt2014flowdroid}，可以做到上下文、路径、对象、字段等层面上的敏感。
FlowDroid通过定义数据源点和数据泄漏点，在Android应用生命周期的基础上，可以实现数据流敏感的污点分析。
但其不足之处在于缺少跨组件通信的分析不考虑多线程调用问题。
在FlowDroid基础上，卢森堡大学的Li Li等人推出了IccTA\cite{iccta}，利用跨组件通信分析工具IC3提取跨组件通信\eat{（Inter-Component Communication, ICC）}的方法调用，并结合AndroidManifest.xml文件定义的Intent Filter信息，连接ICC两端的组件，克服了FlowDroid因缺少跨组件通信而导致的数据流上的缺失。
因为它是构建在FlowDroid之上的一个探测敏感信息泄露的，所以受限于FlowDroid的局限性。
Yang等人~\cite{yang2015static}，利用静态分析技术，并将回调函数添加到控制流图（调用图）中，形成了回调函数控制流图\eat{（Callback control-flow gragh）}。
实验结果显示，Yang的工作比Gator~\cite{rountev2014static}在控件监听器绑定上得到了更为准确结果。
%法国和意大利的学者~\cite{payet2012static}通过对Java字节码静态分析器Julia进行扩展，使得其支持对 Android 应用程序的静态分析；
%他们通过改写 Android 库中 Activity、LayoutInflater 等类的代码逻辑，规避了Android系统分析常见难点(如程序的事件机制，基于反射的视图加载等)，
%实现了包括死代码检查、空指针检查在内的7种静态分析技术。



%由此可见，静态分析工具在分析过程中虽然可以对应用程序进行较为全面的分析，覆盖应用程序的所有代码，但由于缺少和程序执行过程相关的部分必要信息（应用程序的执行序列、和设备所处环境相关的传感器（如GPS、温度等）信息等），可能导致部分情况下分析结果的不精确。为了解决这一问题，研究人员提出了动态分析技术。


\subsection{动态分析技术}

% 为了解决这一问题，研究人员提出了动态分析技术。
和静态分析技术相对应，动态分析技术通过执行应用程序，获取程序运行过程的相关信息，从而实现对应的研究目的。
动态分析技术往往需要对运行环境做适当的修改或者调用特殊的系统接口，记录应用程序运行过程的关键信息，结合数据流追踪等技术，已记录应用程序的运行时行为。
这方面的工作代表包括\cite{chun2014taintdroid,droidbox:online,van2013dynamic,droidscope}等。
Enck等人提出的TaintDroid\cite{chun2014taintdroid}，是一个高效的系统级的动态污点跟踪和分析系统。它通过修改Dalvik虚拟机，利用动态污点分析技术实时监控敏感数据的生成、传播和泄露，实现了变量层面、方法层面、文件层面的数据追踪。
此外，TaintDroid还支持跨进程通信（IPC）层面上的污点分析，因此可以精确分析出应用程序从消费者手机上获取和发布隐私信息的完整传播过程。
TaintDroid提供了较为完备的数据流分析技术，但是不支持控制流追踪，无法给出相关语句的执行路径。
DroidBox\cite{droidbox:online}在TaintDroid基础上，对Android Framework的部分API做了修改，可以记录一些开发人员感兴趣的API（例如文件读写、网络请求、SMS服务等）的调用，并提供分析结果的可视化。
同时，DroidBox还实现了应用程序的自动安装和执行，弥补了TaintDroid在软件测试自动化方面的不足。
和TaintDroid不同，TraceDroid\cite{van2013dynamic}采用的是另一种思路，利用字节码插装技术AspectJ，使得方法在执行时输出相应的日志信息。根据这些信息TraceDroid可以还原函数调用图，得到分析结果。
由于Aspect在进行字节码编织时引入的新的方法会导致方法数65K限制问题（即构建APK文件的过程中，方法总数超过65536，进而使得APK文件无法成功构建~\cite{Configur27}），因此该方案存在不稳定的情况。
Inspeckage\cite{acpmInsp34}是一个基于Xposed框架开发的动态分析工具，通过拦截应用程序相关的Android API，帮助用户实时了解应用程序的运行时行为（例如文件读写、加解密、网络服务等）。
\eat{


另外，研究人员还用动态分析技术查找Android应用程序在运行时性能瓶颈，辅助程序代码修改以达到提升程序的运行性能的目的。
Android官方性能检测工具SimplePref~\cite{simpleperf:online}就是其中的一个代表：
SimplePref\eat{利用了系统接口pref\_event\_open，}以采样（Sample）的方式获取到CPU性能监视单元的状态\eat{（例如cpu周期数、执行的指令数、缓存失效次数等）}，进而得到程序执行数据\eat{方法执行时间}，辅助性能瓶颈的查找。
%利用这些信息，SimplePref可以得到对应时刻的CPU状态，还原出各个方法的执行时间和对应的执行路径。
受到技术方案的限制，不合理的采样频率会影响实验效果：过快的采样频率会导致过大的系统开销，影响原有程序的执行；反之，过低的采样频率则会丢失部分方法的执行信息。
为此，Uber的Nanoscope\cite{ubernanoscope:online}采用追踪（Trace）技术在定制化的系统Nanoscope OS中运行，在虚拟机解释执行目标方法前后输出相关Trace日志，进而得到性能报告。
相比SimplePref输出所有线程的执行信息，Nanoscope只输出主线程相关的方法数据信息，避免了不必要性能开销。
但是，Nanoscope的局限性在于构建成本较高，需要配合特定的系统使用。
%而且，Android程序关心的性能瓶颈一般都位于主线程，而SimplePref会，实际开销较大。
}



\subsection{分析技术的应用}

上述技术广泛运用在安全性分析、质量保障等领域。

\point{安全性分析：}

安全性分析包括隐私泄露、权限机制研究、恶意软件排查等。
为了弥补Android官方文档权限说明不完整的状况，多伦多大学的Kathy Au等人提出的PScout\cite{au2012pscout}利用Soot对Android系统程序进行静态分析，
构建出Android系统的函数调用图，在调用图中标识权限相关的Binder跨进程调用，结合逆向可达性分析技术得出系统API接口与权限的映射关系，。
%相比其他类似工作，由于考虑了Android系统特性，PScout分析的到结果更加完整，但受到可达性分析的精度限制，存在部分错误的映射关系。
%此外，该团队对Android 2.1 $\sim$  4.0等四个版本的系统源代码进行了广泛的分析，就权限设计的冗余性、无文档说明API的权限要求、权限在Android系统升级的演变等多个研究问题进行深入的探讨。
在PScout的基础上，\textsc{WhyPer}\cite{pandita2013whyper}将自然语言处理技术（NLP）和传统静态分析技术相结合，
可以帮人们找出应用市场中那些应用描述和实际使用到的权限不符的应用。
Wei Yang等人发现一部分恶意应用试图通过模仿正常应用的行为以防止被安全机构识别出来。%，例如恶意软件用到了和正常软件经常使用到的发送短信的功能，
不同的是恶意软件的行为一般在特定条件下（例如深夜）运行。
为此，Wei Yang等人提出了一种基于静态分析技术的解决方案AppContext\cite{yang2015appcontext}：
在FlowDroid提供的函数调用图的基础上，AppContext结合Android常见的系统事件形成ICFG，提取出安全敏感行为的上下文，并利用SVM技术对这些信息进行机器学习，得到最终的安全检测模型。
实验结果显示，AppContext的准确率和召回率分别达到了87.7\%和95\%，实验结果也验证了安全敏感行为的恶意性与该行为的意图(通过上下文反映)的密切关系。
AppIntent\cite{yang2013appintent}利用静态分析技术提取应用程序的时间约束条件，再结合符号执行技术，最后得到用户信息泄露的序列。
AppAudit\cite{xia2015effective}利用静态分析技术找出函数调用图中潜在的数据泄露路径，并利用动态污点分析技术进行进一步确认，在一定程度上减低了结果的假阳性。
相比AppIntent，AppAudit的分析结果准确度更高，时间开销较小。
Marvin\cite{lindorfer2015marvin}从静动态分析技术的分析结果中提取应用的特征（例如应用元数据、类结果、应用运行时行为等），并利用机器学习技术进行训练。
在大规模数据验证的时，Marvin可以识别出98.24\%的恶意软件，假阳性低于0.04\%。
Android应用程序中存在着大量的网络交互，因此，也有一部分研究Socket\cite{Shao2016The,Jia2017Open,bu2017program}聚焦于移动应用的网络安全问题。


%PATDroid\cite{sadeghi2017patdroid}动静态结合


\point{质量保障}

伴随着Android应用程序的发展，研究人员也开始思考如何利用技术手段保障应用本身的质量。
%传统测试观点认为，在测试过程中，如果源代码的覆盖率可以维持在一个较高的水平，可在一定程度上可以覆盖
%其中，提高代码的覆盖率就是非常重要的一个方面。
这方面的工作包括提升软件在测试过程中的代码覆盖率\cite{azim2013targeted,yang2013grey,su2016fsmdroid,androidtest2}、错误定位\cite{mirzaei2015exception,machado2013mzoltar}、错误修复分析\cite{tan2018repairing,QingGaoASE15}以及变异测试\cite{MutationOperatorsAndroid,deng2015towards,linares2017enabling}等。
%t, most GUI testing techniques, e.g., random testing [39, 57], search-based testing [58, 60], and model-based testing [2, 3, 8, 78, 85]
工作\cite{azim2013targeted}利用静态分析工具SCanDroid得到静态Activity迁移图，并结合基于目标探索策略和深度优先探索策略进而达到了较好的Activity覆盖率。
Wei Yang等人的工作\cite{yang2013grey}通过对APP的状态进行建模，在深度优先算法的基础上，使得程序在当前状态无可再遍历状态的情况下进行回溯。
相比传统的深度优先算法，Wei Yang的工作对应的时间开销更小，效率更高。
此外，Stoat\cite{su2016fsmdroid,androidtest2}利用静态、动态分析技术标识出程序本身的状态和事件，从应用中抽象出有限状态机（FSM）模型。
基于该模型，Stoat进行模型变异、测试用例生成与执行、模型迭代，使得应用程序的覆盖率相比之前工作\cite{hao2014puma,amalfitano2015mobiguitar}提升了17$\sim$31\%。
工作\cite{mirzaei2015exception,machado2013mzoltar}等将\eat{传统软件的错误定位技术——}基于频谱的错误定位技术\eat{（spectrum-based fault location，SBFL）}运用在Android应用上，取得了不错的成绩。
工作\cite{tan2018repairing,QingGaoASE15}等主要聚焦如何在Android应用程序出现问题时，根据异常的堆栈信息结合软件变异技术或者问答网站生成补丁代码，实现程序的自动修复。
范玲玲等人的工作\cite{fan2018large}通过开源社区中应用的issue解析分析，从异常种类（应用异常、系统异常、库（Library）异常）、系统异常分类、错误检查工具以及错误修复方式等若干方面进行较为深入的分析、探讨和总结。

\eat{

\point{应用分类：}

Simapp\cite{chen2015simapp}

mobile app tagging \cite{chen2016mobile}

}


% 例如错误定位、自动化分析、profiling等

\section{论文研究内容}

从上述工作中，我们不难发现对Android应用程序运行状态的建模是应用分析中的重要环节。
而函数调用图就是一种重要的展现形式，
Android应用程序的特性（例如，基于事件驱动的架构、面向组件的开发方式、对回调函数和多线程交互的依赖等）使得传统分析工具无法准确对Android应用程序的执行过程无法进行精确的建模，对研究人员了解Android应用程序执行细节造成了困扰。


为此，本文提出了一种可用于还原Android动态函数调用图的技术方案——RunDroid。
%RunDroid通过对程序源代码和运行环境进行预处理，获得程序的运行时信息，最终还原出Android应用程序的动态函数调用图。
RunDroid产出的函数调用图不仅包括方法调用关系，还展示了方法对象、方法间触发关系等信息，可以帮助研究人员全面的了解函数间的关系。
%，提供较为全面地了解应用程序运行时的状态变化。

本文的主要研究工作包括以下：
\begin{itemize}
	%				\setlength{\itemsep}{-5pt}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
%	\item 本文调研最近几年Android应用分析领域的静动态分析工具，了解各项工具的优劣以及相关的应用案例。
%	\item 本文深入Android系统的平台特性，在传统调用图的方法调用关系的基础上，提出了函数触发关系的观念。
%	\item 本文提出并实现Android动态函数调用图构建系统RunDroid。RunDroid生成的函数调用图不仅体现了传统调用图的方法调用关系，还展示方法执行过程相关的对象信息和函数间的触发关系，反映Android平台相关的特性。
%	\item   将RunDroid和静态分析工具进行对比，分析两种技术在生成函数调用图上的优缺点。
	\item  Android动态函数调用图构建系统RunDroid的设计与实现：
	\\
	除了传统调用图的方法调用关系，RunDroid生成的函数调用图还展示方法执行过程相关的对象信息和方法间的触发关系（例如多线程），反映Android平台相关的特性（Activity组件生命周期和事件回调）。
	\item 静动态分析技术效果对比：
	\\
	详细展示和说明RunDroid产生的调用图，并就Activity 生命周期及事件回调、多线程触发关系等角度和与传统静态分析工具FlowDroid产生的静态调用图做了对比分析，并分析两种技术的优劣。
	\item RunDroid系统的应用：
	\\
	利用RunDroid用于开源Android应用的过程分析，反映方法间触发关系在Android系统上的常见性。另外， RunDroid与错误定位技术结合的实验说明RunDroid提供的信息，可以提供更多程序依赖信息，有助于提高错误定位技术技术结果的准确性。
\end{itemize}

%\todo{对上述系统设计对应的实验方案，评估对应的实验效果。}


\section{本文遇到的困难与挑战}


本文解决的关键问题有如下几点：

1)	如何获取应用程序中各个函数的执行信息？

获取应用程序在执行过程中各函数执行信息是本文的基础。从函数分类上，用户定义的方法和系统预定义的方法。
对于前者，我们可以通过修改程序源代码实现；但对于后者，由于我们无法直接修改系统程序的源代码或者构建一个符合本文业务需求的系统的成本较高，
为此，我们需要寻找对应的解决方案以帮助我们获取系统方法的执行信息。

2)	如何根据程序中各函数的的执行信息，还原应用程序的函数调用图？

基于第一点，我们可以获取程序在运行过程中的执行信息。
但仅仅依靠这些执行信息是不够的，我们还需要将这些执行信息组织起来，挖掘执行信息之间的关联关系，从而才能还原成应用程序的函数调用图。
这将是本文研究的重点之一。

3)	如何在生成的函数调用图中体现Android特性？

正如上文所提的，Android系统中有很多常规应用中不具备的特性，例如Activity的生命周期、基于多线程调用的触发关系。
若要在生成的函数调用图上体现上述特性，需要对Android系统源代码有一定的了解熟悉，并基于图中的相关信息创建与特性相对应的关系。
这既是本文研究的重点，也是本文的创新点。


\section{本文组织结构}

\todo{重写}

本文共分为六章，环绕着Android动态函数调用图构建系统的设计与实现展开，各章节内容如下：

\fullref{chp:intro}主要介绍了本文的主要研究背景、相关工作、主要工作内容及本文的工作难点。

\fullref{chp:background}从Android的体系结构出发，介绍了和Android系统相关的背景知识。

\fullref{chp:definition}方法和对象的关系、方法间关系、调用图等方面介绍本文用到的概念做了符号化的定义，并结合文章的例子对概念进行解释说明。

\fullref{chp:design}从系统功能、整体设计思路及设计细节等若干方面介绍RunDroid的设计思想。


\fullref{chp:implement} 从系统组成、模块实现等若干方面介绍RunDroid的设计与实现。

\fullref{chp:testing}将展示RunDroid系统生成的函数调用图的运行结果，并对函数调用图进行详细的阐述。

\fullref{chp:future}对本文工作进行总结，并对下一步工作进行展望。


