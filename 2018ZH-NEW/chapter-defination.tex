\chapter{名称解释}


在本节，我们将给出拓展动态函数调用图构建过程中的基本术语：方法执行、方法对象、调用关系、触发关系、函数调用图、拓展函数调用图等。

\section{概念定义}
方法执行是一个方法执行相关信息的描述，方法对象对应是和方法执行相关的对象；
调用关系和触发关系描述了方法执行之间的关系。
函数调用图为所有调用关系的集合，在函数调用图上添加方法对象以及触发关系得到拓展函数调用图。相关定义如下：

\subsection{关于方法和对象的定义}

\begin{myDef}
	方法对象（Method Object，MO）
\end{myDef}
	和方法执行相关的对象称为方法对象，可以体现对象和执行方法的相互关系。
	在本文中，方法对象通常用符号$o$表示。
	
	
	对于一个方法执行$m$，对象和方法执行的关系有如下几种：
	\begin{itemize}
		\item 若对象$o_p$是这个方法$m$的参数，记为$o_p \stackrel{parameter}{\longrightarrow} m$，或者 $ rel(m,o_p) = parameter$；
		\item 若对象$o_r$是这个方法$m$的返回值，记为$o_r \stackrel{return}{\longrightarrow} m$，或者 $ rel(m,o_r) = return$；
		\item 若方法$m$是非静态方法，则方法执行时我们可以获取到关联到的this指针对象$o_i$，记为$o_i \stackrel{instance}{\longrightarrow} m$，或者 $ rel(m,o_i) = instance$。
	\end{itemize}

\begin{myDef}方法执行\end{myDef}

方法执行是对方法执行过程中的相关信息的描述，完整的信息包括对应方法的完整签名、执行时所处的线程$m_t$以及相关的方法对象。
在本文中，方法执行通常用符号$m$表示。

\subsection{关于方法间关系的定义}
\begin{myDef}
	调用关系（Invoke）
\end{myDef}
	对于程序$P$的两个方法$m_1$和$m_2$，方法$m_1$调用了方法$m_2$，则记作$m_1 \to m_2$，称为方法$m_1$调用方法$m_2$。

\begin{equation}
m_0 \to m_1 \to \dots m_n \to m  \label{equ:extend_invoke}
\end{equation}

在此基础上，对于方法$m$，若存在方法$m_i$（$i=0,\dots,n , n \geqslant 0$），使得~\autoref{equ:extend_invoke}成立，则记作$m_0 \stackrel{\ast}{\to} m$，称为方法$m_0$扩展调用方法$m_n$。
特殊的，对于方法$m_1$和方法$m_2$，若$m_1 \to m_2$，则$m_1  \stackrel{\ast}{\to}  m_2$也成立。

在源代码层面上，如果对于方法$m$和$m'$，$m \to m'$总是成立，可以记为 $m \Rightarrow m'$；
如果对于方法$m$和$m'$，$m  \stackrel{\ast}{\to}  m'$总是成立，可以记为 $m  \stackrel{\ast}{ \Rightarrow } m'$。

\begin{myDef}
	触发关系（Trigger）
\end{myDef}
	
	%如果对于动态函数调用图$DCG$中两个方法（不妨记为$m_a$和$m_b$，$m_a \in DCG$，$m_b \in DCG $），
	若方法$m_a$和方法$m_b$之间同时需要满足以下三个条件，
	则两个方法存在触发关系，记为$m_a \hookrightarrow m_b$，称为$m_a$触发调用$m_b$：
	
	\begin{itemize}
		\item 方法$m_a$的执行时间总是在方法$m_b$的执行时间之前；
		\item $m_a \stackrel{\ast}{\to} m_b $不成立；
		\item $m_a$、$m_b$之间存在着一定的因果关系，包括但不限于生命周期事件，UI交互事件或多线程通信等。
	\end{itemize}

在源代码层面上，对于方法$m_a$ ,$m_b$ ,$m_c$ ，
若$m_a  \stackrel{\ast}{ \Rightarrow } m_b$ 和 $m_b \hookrightarrow m_c$同时成立，则$m_a \hookrightarrow m_c$也成立；
若$m_a  \hookrightarrow m_b$ 和 $m_b \stackrel{\ast}{ \Rightarrow }  m_c$同时成立，则$m_a \hookrightarrow m_c$也成立。

\subsection{关于调用图的定义}

\begin{myDef}
	函数调用图（CallGraph，CG）
\end{myDef}	
	函数调用图是对程序运行时行为的描述，用有向图$CG = ( V , E)$表示。 图中的点$ v \in V $表示一个\textbf{方法执行} $m$；
	如果方法$m_1$调用方法$m_2$（即$m_1 \to m_2$），则有向边 $e = (m_1 ,m_2)$属于集合 $E$。 


\textbf{注意：}
在应用执行过程中，方法A被调用了两次，方法A的每次调用都调用了方法B，则对应的函数调用图$CG$如~\autoref{equ:dcg_sample}所示。
在调用图$CG$中，$m_a$ 和 $m_b$ 各有两个，分别对应的两次\textbf{方法执行}。
$(m_{a_{(1)}} \to m_{b_{(1)}})$对应的是第一次函数A调用函数B，
$(m_{a_{(2)}} \to m_{b_{(2)})}$对应的是第二次函数A调用函数B，

\begin{equation}
\begin{aligned}
CG = &(V,E) ,\\ 
V = & \{m_{a_{(1)}},m_{b_{(1)}},m_{a_{(2)}},m_{b_{(2)}}\}, \\ 
E = & \{  
(  m_{a_{(1)}} \to m_{b_{(1)}}) ,( m_{a_{(2)}} \to m_{b_{(2)}})
\} 
\end{aligned}
\label{equ:dcg_sample} 
\end{equation}



\begin{myDef}
	拓展函数调用图（Extended Dynamic CallGraph，EDCG）
\end{myDef}
	在函数调用图（DCG）的基础上，添加了方法对象和函数间的触发关系。
	拓展函数调用图中的节点包括方法执行节点和方法对象节点。图中的边包括描述方法间关系的边和描述方法和对象间的边：
	前者的方法间关系包括调用关系和触发关系；而后者的关系包括和方法对象相关的三个关系。
	具体定义如~\autoref{equ:def_edcg}所示：
	
	\begin{equation}
	\begin{aligned}
	EDCG =              & (V_{EDCG},E_{EDCG}) ,\\ 
	DCG =                & (V_{DCG},E_{DCG}) ,\\ 
	V_{EDCG} =      & V_{method} \bigcup V_{object} ,\\
	V_{method} =   & V_{DCG}, \\ 
	G_{EDCG} =      & G_{method} \bigcup G_{object} , \\
	G_{method} =  & E_{DCG} \bigcup \{ (m_1 , m_2) \mid m_1 \hookrightarrow m_2 \}
	\end{aligned}
	\label{equ:def_edcg} 
	\end{equation}
	
	
\section{举例}
\foreach \n in {1,...,9}{举个栗子吧，大佬 


}


\section{本章小结}
