\chapter{总结与展望}
\label{chp:future}
\section{总结}


\todo{总结}


为了反映Android应用程序的执行过程，本文提出了一个可用于生成Android应用程序动态函数调用图的系统——RunDroid。

%RunDroid以帮助用户（开发人员）了解Android应用程序的执行过程作为基本出发点，让Android应用在执行时输出相应的执行日志信息，进而利用这些日志信息恢复Android应用程序执行时的动态调用图。
在具体实现上，我们通过对源代码进行日志插桩的方式输出程序在应用层上的执行信息，利用Xposed可以改变Android系统行为的特性进行系统方法的拦截处理，从而记录Android系统内部的执行信息。

RunDroid的设计与实现：RunDroid利用源程序代码插桩和运行时方法拦截相结合的方式，获取应用方法执行信息，构建函数调用图；并在此基础上，利用方法和对象的关系补全到调用图中的方法间触发关系，展现运行过程中的Android特性行为。


静动态分析技术效果对比：详细展示和说明RunDroid产生的调用图，并就Activity 生命周期及事件回调、多线程触发关系等角度和与传统静态分析工具FlowDroid产生的静态调用图做了对比分析，并分析两种技术的优劣。

RunDroid系统的应用：利用RunDroid用于开源Android应用的过程分析，反映方法间触发关系在Android系统上的常见性。另外， RunDroid与错误定位技术结合的实验说明RunDroid提供的信息，可以提供更多程序依赖信息，有助于提高错误定位技术技术结果的准确性。

\eat{
RunDroid以帮助用户（开发人员）了解Android应用程序的执行过程作为基本出发点，让Android应用在执行时输出相应的执行日志信息，进而利用这些日志信息恢复Android应用程序执行时的动态调用图。
在具体实现上，我们通过对源代码进行日志插桩的方式输出程序在应用层上的执行信息，利用Xposed可以改变Android系统行为的特性进行系统方法的拦截处理，从而记录Android系统内部的执行信息。
除了展示方法间的调用关系之外，RunDroid考虑到Android系统上的多线程调用场景，提供多线程触发关系展示的功能：RunDroid对日志进行初步处理，在Neo4j图数据库上构建程序调用图，根据具体的多线程调用规则结合Soot提供的实现类查询服务，生成对应的Cypher脚本语句，在对应的节点之间创建对应的触发关系，展现了方法间的多线程触发关系。
这个方案思路清晰简洁，可以从方法调用、方法间的触发关系、相关对象信息等多个方面较为全面地展现Android应用的执行过程，具有一定的通用性和拓展性。
}

\eat{
本文尝试提出一个Android动态函数调用图构建系统，从应用层和系统层对Android应用程序的执行过程进行记录，并利用得到的执行日志信息还原Android应用程序的动态函数调用图，从方法层面还原程序的执行过程。
另外，通过Android系统的源代码进行分析，我们可以找到Android应用程序中多线程相关的函数触发关系，进一步全面的展现Android应用程序的执行过程。
另外，开发人员还可以对系统进行拓展，实现自身的需求。
}

\section{展望}

虽然通过RunDroid还原得到的Android应用程序动态函数调用图，反映程序的运行时状态，但在实验过程中我们发现以下问题：

（1）RunDroid在捕获应用用户层方法时，采用的方案是源代码插桩方案。
调用图构建的前置条件需要提供Android 应用的源代码。
系统运行对源代码高度依赖，现在阶段的RunDroid更适用于企业开发环境，和工业生产环境下应用还存在一定的距离。

（2）在实验阶段，我们发现，当应用程序长时间运行时，应用程序会产生较多的日志。
通常的，移动设备上的存储是有限的。
因此，对于一些调用关系较为复杂的应用，RunDroid的日志方案比较容易遇到日志存储的瓶颈。

（3）RunDroid中的运行时拦截器是基于Xposed框架实现的。Xposed框架并不是适用于所有的Android手机，在一定程度给RunDroid的实验环境提出了额外的要求。

整体上，本文提出的RunDroid较为准确地还原出Android应用程序在运行过程的函数调用图。
主要的改进方法：利用字节码修改技术代替源代码修改方案以减少RunDroid运行过程中对源代码的依赖；
引入基于JVMTI的调试环境，借助调试技术实现系统方法执行的拦截，摆脱对Xposed环境的依赖；
通过静态分析技术确定运行过程的确定性路径，缩减待插桩的用户方法数量，进而减少运行时日志的产出量，同时在构建函数姐需要等。